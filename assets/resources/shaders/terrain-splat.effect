// Terrain Splatmap Shader — blends grass + dirt using a grayscale mask
// Single draw call for the entire ground plane

CCEffect %{
  techniques:
  - name: opaque
    passes:
    - vert: terrain-vs:vert
      frag: terrain-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: true
      rasterizerState:
        cullMode: none
      properties:
        grassTex:     { value: white }
        dirtTex:      { value: white }
        splatMap:     { value: black }
        grassTiling:  { value: [8.0, 8.0, 0.0, 0.0] }
        dirtTiling:   { value: [8.0, 8.0, 0.0, 0.0] }
        splatTexel:   { value: [0.00390625, 0.00390625, 0.0, 0.0] }
        lightDir:     { value: [-0.35, 1.0, 0.25, 0.0] }
        lightingParams: { value: [0.62, 0.52, 2.4, 0.16] }
}%

CCProgram terrain-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>

  in vec3 a_position;
  in vec2 a_texCoord;

  out vec2 v_uv;

  vec4 vert () {
    v_uv = a_texCoord;
    return cc_matProj * cc_matView * cc_matWorld * vec4(a_position, 1.0);
  }
}%

CCProgram terrain-fs %{
  precision highp float;

  in vec2 v_uv;

  uniform sampler2D grassTex;
  uniform sampler2D dirtTex;
  uniform sampler2D splatMap;

  uniform TerrainParams {
    vec4 grassTiling;
    vec4 dirtTiling;
    vec4 splatTexel;
    vec4 lightDir;
    vec4 lightingParams;
  };

  vec4 frag () {
    // Sample splatmap (single channel mask: 0=grass, 1=dirt)
    float mask = texture(splatMap, v_uv).r;

    // Tile grass and dirt textures independently
    vec2 grassUV = v_uv * grassTiling.xy + grassTiling.zw;
    vec2 dirtUV  = v_uv * dirtTiling.xy  + dirtTiling.zw;

    vec4 grassColor = texture(grassTex, grassUV);
    vec4 dirtColor  = texture(dirtTex, dirtUV);

    // Blend: mask=0 → grass, mask=1 → dirt
    vec4 finalColor = mix(grassColor, dirtColor, mask);

    // Pseudo lighting from splat-map gradient to avoid overly flat unlit ground.
    float maskL = texture(splatMap, v_uv - vec2(splatTexel.x, 0.0)).r;
    float maskR = texture(splatMap, v_uv + vec2(splatTexel.x, 0.0)).r;
    float maskD = texture(splatMap, v_uv - vec2(0.0, splatTexel.y)).r;
    float maskU = texture(splatMap, v_uv + vec2(0.0, splatTexel.y)).r;
    vec2 grad = vec2(maskR - maskL, maskU - maskD);

    vec3 pseudoNormal = normalize(vec3(-grad.x * lightingParams.z, 1.0, -grad.y * lightingParams.z));
    vec3 l = normalize(lightDir.xyz);
    float ndl = max(dot(pseudoNormal, l), 0.0);
    float litFactor = clamp(lightingParams.x + ndl * lightingParams.y, 0.0, 1.35);

    float edgeOcc = clamp(length(grad) * lightingParams.w, 0.0, 0.25);
    finalColor.rgb *= litFactor * (1.0 - edgeOcc);

    finalColor.a = 1.0;

    return finalColor;
  }
}%
