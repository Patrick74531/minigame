// Copyright (c) 2024 KingShit. All rights reserved.
// SDF Beam Shader — 有向距离场激光光束
// 单四边形 + Fragment Shader 内的全部视觉复杂度
// 性能：1 DrawCall, 0 粒子, 0 后处理

CCEffect %{
  techniques:
  - name: additive
    passes:
    - vert: beam-vs:vert
      frag: beam-fs:frag
      depthStencilState:
        depthTest: true
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one
          blendSrcAlpha: src_alpha
          blendDstAlpha: one
      rasterizerState:
        cullMode: none
      properties:
        beamColor:    { value: [1.0, 0.4, 0.1, 1.0], editor: { type: color } }
        coreColor:    { value: [1.0, 0.9, 0.7, 1.0], editor: { type: color } }
        noiseTex:     { value: white }
        beamWidth:    { value: 0.12 }
        glowWidth:    { value: 0.4  }
        pulseSpeed:   { value: 3.0  }
        pulseScale:   { value: 0.15 }
        noiseScale:   { value: 8.0  }
        noiseAmp:     { value: 0.03 }
        intensity:    { value: 2.0  }
        fadeIn:       { value: 0.05 }
        fadeOut:       { value: 0.05 }
        time:         { value: 0.0  }
}%

CCProgram beam-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/uniforms/cc-local>

  in vec3 a_position;
  in vec2 a_texCoord;

  out vec2 v_uv;

  vec4 vert () {
    v_uv = a_texCoord;
    return cc_matProj * cc_matView * cc_matWorld * vec4(a_position, 1.0);
  }
}%

CCProgram beam-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>

  in vec2 v_uv;

  uniform sampler2D noiseTex;
  uniform BeamParams {
    vec4  beamColor;
    vec4  coreColor;
    float beamWidth;
    float glowWidth;
    float pulseSpeed;
    float pulseScale;
    float noiseScale;
    float noiseAmp;
    float intensity;
    float fadeIn;
    float fadeOut;
    float time;
  };

  // ======= 伪噪声（纯数学，无贴图） =======
  float hash(float n) {
    return fract(sin(n) * 43758.5453123);
  }

  float noise1D(float x) {
    float i = floor(x);
    float f = fract(x);
    f = f * f * (3.0 - 2.0 * f); // smoothstep
    return mix(hash(i), hash(i + 1.0), f);
  }

  // ======= SDF 圆角矩形（光束截面） =======
  float sdRoundedBox(vec2 p, vec2 b, float r) {
    vec2 q = abs(p) - b + vec2(r);
    return length(max(q, vec2(0.0))) + min(max(q.x, q.y), 0.0) - r;
  }

  vec4 frag () {
    // uv.x = 沿光束方向 [0,1], uv.y = 垂直于光束 [0,1]
    // 重映射 y 到 [-0.5, 0.5] 范围
    vec2 uv = v_uv;
    float beamU = uv.x;           // 沿光束方向
    float beamV = uv.y - 0.5;     // 中心线距离 [-0.5, 0.5]

    // ======= 边缘噪声扰动 =======
    float n = noise1D(beamU * noiseScale + time * 2.0) * 2.0 - 1.0;
    float n2 = noise1D(beamU * noiseScale * 1.7 - time * 1.3) * 2.0 - 1.0;
    vec2 noiseUv = vec2(beamU * noiseScale * 0.08 + time * 0.08, beamV * 2.5 + time * 0.12);
    float texN = texture(noiseTex, noiseUv).r * 2.0 - 1.0;
    float edgeNoise = (n * 0.45 + n2 * 0.35 + texN * 0.2) * noiseAmp;

    // 扰动后的垂直距离
    float dist = abs(beamV + edgeNoise);

    // ======= 核心光束（SDF 硬边） =======
    float halfBeam = beamWidth * 0.5;
    float core = 1.0 - smoothstep(halfBeam * 0.3, halfBeam, dist);

    // ======= 辉光衰减（指数） =======
    float halfGlow = glowWidth * 0.5;
    float glow = exp(-dist * dist / (halfGlow * halfGlow * 0.15));

    // ======= 能量脉冲（沿光束方向滚动） =======
    float pulsePhase = beamU * 12.0 - time * pulseSpeed;
    float pulse = sin(pulsePhase) * 0.5 + 0.5;
    float pulse2 = sin(pulsePhase * 2.3 + 1.7) * 0.5 + 0.5;
    float pulseVal = mix(1.0, 1.0 + pulseScale, pulse * 0.7 + pulse2 * 0.3);

    // ======= 首尾淡入淡出 =======
    float headFade = smoothstep(0.0, fadeIn, beamU);
    float tailFade = smoothstep(0.0, fadeOut, 1.0 - beamU);
    float lengthFade = headFade * tailFade;

    // ======= 颜色混合：核心白黄 → 边缘橙红 =======
    float colorT = smoothstep(0.0, halfGlow * 2.0, dist);
    vec3 col = mix(coreColor.rgb, beamColor.rgb, colorT);

    // ======= 最终合成 =======
    float alpha = (core * 0.7 + glow * 0.5) * pulseVal * lengthFade * intensity;
    // 核心区域更亮
    col += coreColor.rgb * core * 0.5 * intensity;

    alpha = clamp(alpha, 0.0, 1.0);
    return vec4(col * alpha, alpha);
  }
}%
